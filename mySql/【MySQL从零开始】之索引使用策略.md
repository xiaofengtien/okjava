## **正确使用索引**

使用（B-Tree）索引时，有以下一些技巧和注意事项：

## **索引设计：**

> #### 应该创建索引的列
>
> 在经常需要搜索的列上，可以加快搜索的速度
> 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
> 在经常用在连接（JOIN）的列上，这些列主要是一外键，可以加快连接的速度
> 在经常需要根据范围（<，<=，=，>，>=，BETWEEN，IN）进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
> 在经常需要排序（order by）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
> 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
>
> #### 不该创建索引的列
>
> 对于那些在查询中很少使用或者参考的列不应该创建索引。
> 若列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
> 对于那些只有很少数据值或者重复值多的列也不应该增加索引。
> 这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
> 对于那些定义为text, image和bit数据类型的列不应该增加索引。
> 这些列的数据量要么相当大，要么取值很少。
> 当该列修改性能要求远远高于检索性能时，不应该创建索引。（修改性能和检索性能是互相矛盾的）
> 

- **索引字段尽量使用数字型（简单的数据类型）**

若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了

- **尽量不要让字段的默认值为NULL**

在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。

索引不会包含有NULL值的列，只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。

所以我们在数据库设计时尽量不要让字段的默认值为NULL，应该指定列为NOT NULL，除非你想存储NULL。你应该用0、一个特殊的值或者一个空串代替空值。

- **前缀索引和索引选择性**

对串列进行索引，如果可能应该指定一个前缀长度。

对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MYSQL不允许索引这些列的完整长度。

前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做order by和group by，也无法使用前缀索引做覆盖扫描。

一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。

例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。

短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。在绝大多数应用里，数据库中的字符串数据大都以各种各样的名字为主，把索引的长度设置为10~15个字符已经足以把搜索范围缩小到很少的几条数据记录了。

通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。

索引的选择性是指，不重复的索引值（基数）和数据表中的记录总数的比值。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MYSQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

决窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。换句话说，前缀的“基数”应该接近于完整列的“基数”。

为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较。例如以下查询：

```mysql
select count(*) as cnt,city from sakila.city_demo group by city order by cnt desc limit 10;

select count(*) as cnt,left(city,7) as perf from sakila.city_demo group by city order by cnt desc limit 10;
```

直到这个前缀的选择性接近完整列的选择性。

计算合适的前缀长度的另一个方法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性，如下：

```mysql
select count(distinct city)/count(*) from sakila.city_demo;

select count(distinct left(city,7))/count(*) from sakila.city_demo;
```



- **使用唯一索引**

考虑某列中值的分布。索引的列的基数越大，索引的效果越好。

例如，存放出生日期的列具有不同值，很容易区分各行。而用来记录性别的列，只含有“ M” 和“F”，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行。

- **使用组合索引代替多个列索引**

一个多列索引（组合索引）与多个列索引MySQL在解析执行上是不一样的，如果在explain中看到有索引合并（即MySQL为多个列索引合并优化），应该好好检查一下查询的表和结构是不是已经最优。

- **注意重复/冗余的索引、不使用的索引**

MySQL允许在相同的列上创建多个索引，无论是有意还是无意的。大多数情况下不需要使用冗余索引。

对于重复/冗余、不使用的索引：可以直接删除这些索引。因为这些索引需要占用物理空间，并且也会影响更新表的性能。

## **索引使用：**

- **如果对大的文本进行搜索，使用全文索引而不要用使用 like ‘%…%’**
- **like语句不要以通配符开头**

对于LIKE：在以通配符%和_开头作查询时，MySQL不会使用索引。like操作一般在全文索引中会用到（InnoDB数据表不支持全文索引）。

例如下句会使用索引：

```mysql
SELECT * FROM mytable WHERE username like'admin%'
```

而下句就不会使用：

```mysql
SELECT * FROM mytable WHEREt Name like'%admin'
```

- **不要在列上进行运算**

索引列不能是表达式的一部分，也不是是函数的参数。

例如以下两个查询无法使用索引：

```mysql
1）表达式： select actor_id from sakila.actor where actor_id+1=5;

2）函数参数：select ... where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col)<=10;
```

- **尽量不要使用NOT IN、<>、!= 操作**

应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

对于not in，可以用not exists或者（外联结+判断为空）来代替；很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num)

对于<>，用其它相同功能的操作运算代替，如a<>0 改为 a>0 or a<0

- **or条件**

用 or 分割开的条件， 如果 or 前的条件中的列有索引， 而后面的列中没有索引， 那么涉及到的索引都不会被用到。

应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 假设num1有索引，num2没有索引，查询语句select id from t where num1=10 or num2=20会放弃使用索引，可以改为这样查询： select id from t where num1=10 union all select id from t where num2=20，这样虽然num2没有使用索引，但至少num1会使用索引，提高效率。

- **组合索引的使用要遵守“最左前缀”原则'**

组合索引：当不需要考虑排序和分组时，将选择性最高的列放在前面通常是最好的。

例子：

```mysql
CREATE TABLE People (
  last_name varchar(50) not null,
  first_name varchar(50) not null,
  birthday date not null,
  gender enum('m', 'f') not null,
  key(last_name, first_name, birthday)
);
```

1. 查询必须从索引的最左边的列开始，否则无法使用索引。例如，你不能直接利用索引查找在某一天出生的人。
2. 不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。
3. 存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为WHERE last_name="Smith" AND first_name LIKE 'J%' AND dob='1976-12-23'，则该查询只会使用索引中的前两列，因为LIKE是范围查询。

- 使用索引排序时，ORDER BY也要遵守“最左前缀”原则

1. 当索引的顺序与ORDER BY中的列顺序相同，且所有的列是同一方向（全部升序或者全部降序）时，可以使用索引来排序。
2. ORDER BY子句和查询型子句的限制是一样的：需要满足索引的最左前缀的要求，有一种情况下ORDER BY子句可以不满足索引的最左前缀要求，那就是前导列为常量时：WHERE子句或者JOIN子句中对前导列指定了常量。
3. 如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引。其它情况都会使用filesort文件排序。

![img](https://pic1.zhimg.com/80/v2-19d7202ee71287a606f644837d0c19cc_1440w.jpg)

- 如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来，否则的话即便这个列上有索引，MySQL 也不会用到的，因为MySQL 默认把输入的常量值进行转换以后才进行检索,**不然报错或索引失效**。 例如：

<img src="https://pic3.zhimg.com/80/v2-35599795a44296d2763ec240c81a0d02_1440w.jpg" alt="img" style="zoom:33%;" />



<img src="https://pic2.zhimg.com/80/v2-389506a680f6bfb999c1d7559e3245e9_1440w.jpg" alt="img" style="zoom: 50%;" />

- **任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段**
- **如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引。当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。**

## **索引性能测试与索引优化**

只有当数据库里已经有了足够多的测试数据时，它的性能测试结果才有实际参考价值。如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快——不管有没有使用索引。只有当数据库里的记录超过了1000条、数据总量也超过了 MySQL服务器上的内存总量时，数据库的性能测试结果才有意义。

在不确定应该在哪些数据列上创建索引的时候，人们从EXPLAIN SELECT命令那里往往可以获得一些帮助。这其实只是简单地给一条普通的SELECT命令加一个EXPLAIN关键字作为前缀而已。有了这个关键字，MySQL将不是去执行那条SELECT命令，而是去对它进行分析。MySQL将以表格的形式把查询的执行过程和用到的索引(如果有的话)等信息列出来。

**查看索引使用情况：**

- 如果索引正在工作，Handler_read_key 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。
- Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果正进行大量的表扫描， Handler_read_rnd_next 的值较高，则通常说明表索引不正确或写入的查询没有利用索引。

具体如下：

![img](https://pic3.zhimg.com/80/v2-92746b3546a6251de75b77e34cf54272_1440w.jpg)

从上面的例子中可以看出，目前使用的 MySQL 数据库的索引情况并不理想

## 关于索引其他重要的内容补充

### 最左前缀原则

MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，而最左前缀原则指的是，如果查询的时候查询条件==精确匹配==索引的左边连续一列或几列，则此列就可以被用到。如下：        

```                                                                                       mysql
select * from user where name=xx and city=xx ; ／／可以命中索引
select * from user where name=xx ; // 可以命中索引
select * from user where city=xx ; // 无法命中索引            
```

这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。

由于最左前缀原则，在创建联合索引时，==索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面==。ORDER BY子句也遵循此规则。

多个键值得B+树是如下存储的

<img src="/Users/tianxiaofeng/Library/Application Support/typora-user-images/image-20211116143304496.png" alt="image-20211116143304496" style="zoom: 25%;" />

可以看到键值都是排序的，就上面的例子来说(1，1)(1，2)(2，1)(2，4)(3，1)(3，2)，数据按照 (a，b)的顺序进行了存放。

### 注意避免冗余索引

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city）和（name）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

MySQL 5.7 版本后，可以通过查询 sys 库的 `schema_redundant_indexes` 表来查看冗余索引。

### 联合索引优化

1、将区分度最高的字段放在最左边，即索引（a,b）如果b选择性最高，则将索引顺序调整为（b,a）

2、避免出现filesort

> MySQL中，有两种方式生成有序结果集:
>
> 1、通过有序索引顺序扫描直接返回有序数据
>
> 2、 Filesort排序，对返回的数据进行排序
>
> 因为索引的结构是B+树，索引中的数据是按照一定顺序进行排列的，所以在排序查询中如果能利用索引，就能避免 额外的排序操作。EXPLAIN分析查询时，Extra显示为Using index。
>
> 所有不是通过索引直接返回排序结果的操作都是Filesort排序，也就是说进行了额外的排序操作。EXPLAIN分析查 询时，Extra显示为Using filesort，当出现Using filesort时对性能损耗较大，所以要尽量避免Using filesort

### **union**，**or**，**in**都能命中索引，建议使用**in**

新版MySQL的or可以命中索引

效率从高到低为union，in，or。in和union的效率差别可以忽略不计，建议使用in

### 负向条件索引不会使用索引，建议用**in**

负向条件有:!=、<>、not in、not exists、not like 等

### 经常更改，区分度不高的列上不宜加索引

更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。 “性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。 一般区分度在80%以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))/count(*) 来计算

### 明确知道只会返回一条记录，可以加**limit1**

当查询确定只有一条记录时，可以加liimit1，让MySQL停止游标移动，提高查询效率

### 建立索引的列不为NULL

只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。
因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。