**面试官**：**今天要不来聊聊JVM调优相关的吧？**





**面试官**：**你曾经在生产环境下有过调优JVM的经历吗？**





**候选者**：没有





**面试官**：…





**候选者**：嗯…是这样的，我们一般优化系统的思路是这样的





**候选者**：1. 一般来说关系型数据库是先到瓶颈，首先排查是否为数据库的问题





**候选者**：（这个过程中就需要评估自己建的索引是否合理、是否需要引入分布式缓存、是否需要分库分表等等）





**候选者**：2. 然后，我们会考虑是否需要扩容（横向和纵向都会考虑）





**候选者**：（这个过程中我们会怀疑是系统的压力过大或者是系统的硬件能力不足导致系统频繁出现问题）





**候选者**：3. 接着，应用代码层面上排查并优化





**候选者**：（扩容是不能无止境的，里头里外都是钱阿。这个过程中我们会审视自己写的代码是否存在资源浪费的问题，又或者是在逻辑上可存在优化的地方，比如说通过并行的方式处理某些请求）





**候选者**：4. 再接着，JVM层面上排查并优化





**候选者**：（审视完代码之后，这个过程我们观察JVM是否存在多次GC问题等等）





**候选者**：5. 最后，网络和操作系统层面排查





**候选者**：（这个过程查看内存/CPU/网络/硬盘读写指标是否正常等等）



![img](https://pics7.baidu.com/feed/b7003af33a87e950906da138c761284afaf2b4cb.jpeg?token=55541cce8141fe599db4421a14ad6619)



**候选者**：绝大多数情况下，到第三步就结束了，一般经过「运维团队」给我们设置的JVM和机器上的参数，已经满足绝大多数的需求了。





**候选者**：之前有过其他团队在「大促」发现接口处理超时的问题，那时候查各种监控怀疑是FULL GC导致的





**候选者**：第一想法不是说去调节各种JVM参数来进行优化，而是直接加机器





**候选者**：（用最粗暴的方法，解决问题是最简单的，扩容YYDS）





**面试官**：确实





**候选者**：不过，我是学过JVM相关的调优命令和思路的。





**候选者**：在我的理解下，调优JVM其实就是在「理解」JVM内存结构以及各种垃圾收集器前提下，结合自己的现有的业务来「调整参数」，使自己的应用能够正常稳定运行。





**候选者**：一般调优JVM我们认为会有几种指标可以参考：『吞吐量』、『停顿时间』和『垃圾回收频率』





**候选者**：基于这些指标，我们就有可能需要调整：





**候选者**：1. 内存区域大小以及相关策略（比如整块堆内存占多少、新生代占多少、老年代占多少、Survivor占多少、晋升老年代的条件等等）





**候选者**：比如（-Xmx：设置堆的最大值、-Xms：设置堆的初始值、-Xmn：表示年轻代的大小、-XX:SurvivorRatio：伊甸区和幸存区的比例等等）





**候选者**：（按经验来说：IO密集型的可以稍微把「年轻代」空间加大些，因为大多数对象都是在年轻代就会灭亡。内存计算密集型的可以稍微把「老年代」空间加大些，对象存活时间会更长些）





**候选者**：2. 垃圾回收器（选择合适的垃圾回收器，以及各个垃圾回收器的各种调优参数）





**候选者**：比如（-XX:+UseG1GC：指定 JVM 使用的垃圾回收器为 G1、-XX:MaxGCPauseMillis：设置目标停顿时间、-XX:InitiatingHeapOccupancyPercent：当整个堆内存使用达到一定比例，全局并发标记阶段 就会被启动等等）





**候选者**：没错，这些都是因地制宜，具体问题具体分析（前提是得懂JVM的各种基础知识，基础知识都不懂，谈何调优）





**候选者**：在大多数场景下，JVM 已经能够达到「开箱即用」



![img](https://pics3.baidu.com/feed/b8389b504fc2d5624837925c2048ebe676c66c23.jpeg?token=56917057345f126dac23ac5b48abda7e)



**面试官**：确实





**候选者**：一般我们是「遇到问题」之后才进行调优的，而遇到问题后需要利用各种的「工具」进行排查





**候选者**：1. 通过jps命令查看Java进程「基础」信息（进程号、主类）。这个命令很常用的就是用来看当前服务器有多少Java进程在运行，它们的进程号和加载主类是啥





**候选者**：2. 通过jstat命令查看Java进程「统计类」相关的信息（类加载、编译相关信息统计，各个内存区域GC概况和统计）。这个命令很常用于看GC的情况





**候选者**：3. 通过jinfo命令来查看和调整Java进程的「运行参数」。





**候选者**：4. 通过jmap命令来查看Java进程的「内存信息」。这个命令很常用于把JVM内存信息dump到文件，然后再用MAT( Memory Analyzer tool 内存解析工具)把文件进行分析





**候选者**：5. 通过jstack命令来查看JVM「线程信息」。这个命令用常用语排查死锁相关的问题





**候选者**：6. 还有近期比较热门的Arthas（阿里开源的诊断工具），涵盖了上面很多命令的功能且自带图形化界面。这也是我这边常用的排查和分析工具



![img](https://pics5.baidu.com/feed/cf1b9d16fdfaaf51bdf3b3fc4c0defe7f11f7ac7.jpeg?token=6ea1d40de89cd3601202e4993e777832)



**面试官**：嗯…好吧。之前聊JVM的时候，你也提到过在「解释」阶段，会有两种方式把字节码信息解释成机器指令码，一个是字节码解释器、一个是即时编译器(JIT)





**面试官**：**我想问问，你了解JVM的JIT优化技术嘛？**





**候选者**：JIT优化技术比较出名的有两种：方法内联和逃逸分析





**候选者**：所谓方法内联就是把「目标方法」的代码复制到「调用的方法」中，避免发生真实的方法调用





**候选者**：因为每次方法调用都会生成栈帧（压栈出栈记录方法调用位置等等）会带来一定的性能损耗，所以「方法内联」的优化可以提高一定的性能





**候选者**：在JVM中也有相关的参数给予我们指定（-XX:MaxFreqInlineSize、-XX:MaxInlineSize）





**候选者**：而「逃逸分析」则是判断一个对象是否被外部方法引用或外部线程访问的分析技术，如果「没有被引用」，就可以对其进行优化，比如说：





**候选者**：1. 锁消除（同步忽略）：该对象只在方法内部被访问，不会被别的地方引用，那么就一定是线程安全的，可以把锁相关的代码给忽略掉





**候选者**：2. 栈上分配：该对象只会在方法内部被访问，直接将对象分配在「栈」中（Java默认是将对象分配在「堆」中，是需要通过JVM垃圾回收期进行回收，需要损耗一定的性能，而栈内分配则快很多）





**候选者**：3. 标量替换/分离对象：当程序真正执行的时候可以不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了



![img](https://pics6.baidu.com/feed/b3b7d0a20cf431ad7d2a0f13836fd7a62fdd9887.jpeg?token=2d3be7b49ac45b59e5b43325cea6c318)



**候选者**：不过扯了这么多，不同的JVM版本对JIT的优化都不太相同（：这里也只能算是一个参考